# denite.nvim
[[plugins]]
repo = 'Shougo/denite.nvim'
on_cmd = 'Denite'
depends = [
    'neomru.vim',
    'neoyank.vim'
    ]
hook_source = '''
    " Key mapping.
    call denite#custom#map(
                \ 'insert',
                \ '<C-n>',
                \ '<denite:move_to_next_line>',
                \ 'noremap'
                \ )
    call denite#custom#map(
                \ 'insert',
                \ '<C-p>',
                \ '<denite:move_to_previous_line>',
                \ 'noremap'
                \ )

    " Command option.
    call denite#custom#option('_', 'winheight', 16)
    call denite#custom#option('_', 'highlight_mode_insert', 'Search')
    call denite#custom#option('_', 'previewheight', 100)

    " Change matches to perfect matching.
    call denite#custom#source('_', 'matchers',
        \ ['matcher/substring'])

    call denite#custom#source('buffer', 'matchers',
        \ ['matcher/fuzzy', 'matcher/project_files'])

    " Ripgrep command on file/rec source.
    call denite#custom#var('file/rec', 'command',
        \ ['rg', '--hidden', '--glob', '!.git/*', '--files'])

    " Ripgrep command on grep source.
    " Reference 
    " https://github.com/BurntSushi/ripgrep/issues/73
    call denite#custom#var('grep', 'command', ['rg'])
    call denite#custom#var('grep', 'recursive_opts', [])
    call denite#custom#var('grep', 'final_opts', [])
    call denite#custom#var('grep', 'separator', ['--'])
    call denite#custom#var('grep', 'default_opts',
        \ ['--vimgrep', '--no-heading', '--hidden', '--glob', '!.git/*', '--color', 'never'])
'''

# denite.nvimでファイル表示履歴を表示する。
[[plugins]]
repo = 'Shougo/neomru.vim'
hook_source = '''
    let g:neomru#file_mru_limit = 64
    let g:neomru#time_format = "%y/%m/%d %H:%M"
'''

# denite.vimでyankの履歴を表示する。
[[plugins]]
repo = 'Shougo/neoyank.vim'

# File browser
[[plugins]]
repo = 'Shougo/defx.nvim'
on_cmd = 'Defx'
hook_source = '''
    autocmd FileType defx call s:defx_my_settings()
	function! s:defx_my_settings() abort
	  " Define mappings
	  nnoremap <silent><buffer><expr> <CR>
	  \ defx#do_action('open')
	  nnoremap <silent><buffer><expr> c
	  \ defx#do_action('copy')
	  nnoremap <silent><buffer><expr> m
	  \ defx#do_action('move')
	  nnoremap <silent><buffer><expr> p
	  \ defx#do_action('paste')
	  nnoremap <silent><buffer><expr> l
	  \ defx#do_action('open')
	  nnoremap <silent><buffer><expr> E
	  \ defx#do_action('open', 'vsplit')
	  nnoremap <silent><buffer><expr> P
	  \ defx#do_action('open', 'pedit')
	  nnoremap <silent><buffer><expr> o
	  \ defx#do_action('open_or_close_tree')
	  nnoremap <silent><buffer><expr> <C-N>
	  \ defx#do_action('new_directory')
	  nnoremap <silent><buffer><expr> N
	  \ defx#do_action('new_file')
	  nnoremap <silent><buffer><expr> M
	  \ defx#do_action('new_multiple_files')
	  nnoremap <silent><buffer><expr> C
	  \ defx#do_action('toggle_columns',
	  \                'mark:filename:type:size:time')
	  nnoremap <silent><buffer><expr> S
	  \ defx#do_action('toggle_sort', 'time')
	  nnoremap <silent><buffer><expr> D
	  \ defx#do_action('remove')
	  nnoremap <silent><buffer><expr> r
	  \ defx#do_action('rename')
	  nnoremap <silent><buffer><expr> !
	  \ defx#do_action('execute_command')
	  nnoremap <silent><buffer><expr> x
	  \ defx#do_action('execute_system')
	  nnoremap <silent><buffer><expr> yy
	  \ defx#do_action('yank_path')
	  nnoremap <silent><buffer><expr> .
	  \ defx#do_action('toggle_ignored_files')
	  nnoremap <silent><buffer><expr> ;
	  \ defx#do_action('repeat')
	  nnoremap <silent><buffer><expr> h
	  \ defx#do_action('cd', ['..'])
	  nnoremap <silent><buffer><expr> ~
	  \ defx#do_action('cd')
	  nnoremap <silent><buffer><expr> q
	  \ defx#do_action('quit')
	  nnoremap <silent><buffer><expr> <Space>
	  \ defx#do_action('toggle_select') . 'j'
	  nnoremap <silent><buffer><expr> *
	  \ defx#do_action('toggle_select_all')
	  nnoremap <silent><buffer><expr> j
	  \ line('.') == line('$') ? 'gg' : 'j'
	  nnoremap <silent><buffer><expr> k
	  \ line('.') == 1 ? 'G' : 'k'
	  nnoremap <silent><buffer><expr> <C-l>
	  \ defx#do_action('redraw')
	  nnoremap <silent><buffer><expr> <C-g>
	  \ defx#do_action('print')
	  nnoremap <silent><buffer><expr> cd
	  \ defx#do_action('change_vim_cwd')
	endfunction
'''

# Completion
[[plugins]]
repo = 'Shougo/deoplete.nvim'
depends = [
    'deoplete-dictionary',
    'deoplete-tag'
    ]
hook_source = '''
    call deoplete#custom#option({
        \ 'smart_case': v:true,
        \})

    call deoplete#custom#option('keyword_patterns', {
        \ '_': '[a-zA-Z_]\k*',
        \})

    call deoplete#custom#option('sources', {
        \ 'scala': ['buffer', 'file', 'member', 'omni', 'dictionary', 'tag'],
        \})

    call deoplete#custom#source('_', 
        \ 'matchers', ['matcher_head'])

    call deoplete#custom#var('omni', 'input_patterns', {
        \ 'scala': [
        \     '[^. *\t]\.\w*',
        \     '[:\[,] ?\w*',
        \     '^import .*'
        \   ]
        \})

    call deoplete#enable()

    inoremap <expr><CR>  pumvisible() ? deoplete#mappings#close_popup() : "<CR>"
'''

[[plugins]]
repo = 'deoplete-plugins/deoplete-dictionary'

[[plugins]]
repo = 'deoplete-plugins/deoplete-tag'

# Completion for Scala
# $ sbt ensimeConfig
# $ sbt ensimeConfigProject
[[plugins]]
repo = 'ensime/ensime-vim'

# Asynchronous linting/fixing for Vim and Language Server Protocol (LSP) integration
[[plugins]]
repo = 'w0rp/ale'
on_ft = 'scala'
hook_source = '''
    let g:ale_completion_enabled = 1
'''
depends = [
    'ensime-vim'
]

# Completion for other language
# Rust: https://github.com/rust-lang/rls
[[plugins]]
repo = 'autozimu/LanguageClient-neovim'
rev = 'next'
build = 'bash install.sh'
on_ft = 'rust'
hook_source = '''
    set hidden
    set completeopt=menu
    set signcolumn=yes

    let g:LanguageClient_useVirtualText = 0

    let g:LanguageClient_serverCommands = {
        \ 'rust': ['~/.cargo/bin/rustup', 'run', 'stable', 'rls'],
        \ }

    function! s:restartLanguageClient()
        LanguageClientStop
        sleep 300m
        LanguageClientStart
    endfunction

    augroup languageClient-neovim
        autocmd!
        autocmd BufWritePre *.rs call s:restartLanguageClient()
    augroup END

    command! LanguageClientReStart call s:restartLanguageClient()

    LanguageClientReStart
'''

# emmet-vim
[[plugins]]
repo = 'mattn/emmet-vim'
on_ft = ['html', 'css', 'javascript', 'javascript.jsx', 'typescript', 'typescript.tsx']
hook_source = '''
    let g:user_emmet_install_global = 0
    augroup emmet-vim
        autocmd!
        autocmd FileType html,css,javascript,javascript.jsx,typescript,typescript.tsx EmmetInstall
    augroup END
'''

# Scala のシンタックスハイライト
[[plugins]]
repo = 'derekwyatt/vim-scala'
on_ft = 'scala'

# JSX Syntax
[[plugins]]
repo = 'mxw/vim-jsx'
on_ft = 'javascript'

# Syntax Highlighting and Indentation for Haskell and Cabal
[[plugins]]
repo = 'neovimhaskell/haskell-vim'
on_ft = 'haskell'
hook_source = '''
    let g:haskell_indent_guard = 4
'''

# toml syntax
[[plugins]]
repo = 'cespare/vim-toml'
on_ft = 'toml'

# TypeScript syntax
[[plugins]]
repo = 'leafgarland/typescript-vim'
on_ft = 'typescript'

# Provides more syntax highlighting and DOM keywords for TypeScript
[[plugins]]
repo = 'HerringtonDarkholme/yats.vim'
on_ft = 'typescript'

# Typescript tooling for Neovim
[[plugins]]
repo = 'mhartington/nvim-typescript'
build = './install.sh'
on_ft = 'typescript'

# Vim configuration for Rust.
[[plugins]]
repo = 'rust-lang/rust.vim'
on_ft = 'rust'
hook_source = '''
    let g:rustfmt_command = 'rustfmt'
    let g:rustfmt_autosave = 1 
'''

[[plugins]]
repo = 'jdonaldson/vaxe'
on_ft = 'haxe'
hook_source = '''
    let g:vaxe_haxe_version = 3
'''

# Translate Japanese/English
[[plugins]]
repo = 'nabezokodaikon/jaen-translate.vim'
on_cmd = 'JaEnTranslate'

[[plugins]]
repo = 'neoclide/coc.nvim'
build = 'yarn install --frozen-lockfile'
on_event = 'InsertEnter'
hook_source = '''
    " if hidden is not set, TextEdit might fail.
    set hidden

    " Some servers have issues with backup files, see #649
    set nobackup
    set nowritebackup

    " Better display for messages
    set cmdheight=2

    " Smaller updatetime for CursorHold & CursorHoldI
    set updatetime=300

    " don't give |ins-completion-menu| messages.
    set shortmess+=c

    " always show signcolumns
    set signcolumn=yes

    " Use tab for trigger completion with characters ahead and navigate.
    " Use command ':verbose imap <tab>' to make sure tab is not mapped by other plugin.
    inoremap <silent><expr> <TAB>
          \ pumvisible() ? "\<C-n>" :
          \ <SID>check_back_space() ? "\<TAB>" :
          \ coc#refresh()
    inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

    function! s:check_back_space() abort
      let col = col('.') - 1
      return !col || getline('.')[col - 1]  =~# '\s'
    endfunction

    " Use <c-space> to trigger completion.
    inoremap <silent><expr> <c-space> coc#refresh()

    " Use <cr> to confirm completion, `<C-g>u` means break undo chain at current position.
    " Coc only does snippet and additional edit on confirm.
    inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

    " Use `[c` and `]c` to navigate diagnostics
    nmap <silent> [c <Plug>(coc-diagnostic-prev)
    nmap <silent> ]c <Plug>(coc-diagnostic-next)

    " Remap keys for gotos
    nmap <silent> gd <Plug>(coc-definition)
    nmap <silent> gy <Plug>(coc-type-definition)
    nmap <silent> gi <Plug>(coc-implementation)
    nmap <silent> gr <Plug>(coc-references)

    " Use K to show documentation in preview window
    nnoremap <silent> K :call <SID>show_documentation()<CR>

    function! s:show_documentation()
      if (index(['vim','help'], &filetype) >= 0)
        execute 'h '.expand('<cword>')
      else
        call CocAction('doHover')
      endif
    endfunction

    " Highlight symbol under cursor on CursorHold
    autocmd CursorHold * silent call CocActionAsync('highlight')

    " Remap for rename current word
    nmap <leader>rn <Plug>(coc-rename)

    " Remap for format selected region
    vmap <leader>f  <Plug>(coc-format-selected)
    nmap <leader>f  <Plug>(coc-format-selected)

    augroup mygroup
      autocmd!
      " Setup formatexpr specified filetype(s).
      autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
      " Update signature help on jump placeholder
      autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
    augroup end

    " Remap for do codeAction of selected region, ex: `<leader>aap` for current paragraph
    vmap <leader>a  <Plug>(coc-codeaction-selected)
    nmap <leader>a  <Plug>(coc-codeaction-selected)

    " Remap for do codeAction of current line
    nmap <leader>ac  <Plug>(coc-codeaction)
    " Fix autofix problem of current line
    nmap <leader>qf  <Plug>(coc-fix-current)

    " Use `:Format` to format current buffer
    command! -nargs=0 Format :call CocAction('format')

    " Use `:Fold` to fold current buffer
    command! -nargs=? Fold :call     CocAction('fold', <f-args>)


    " Add diagnostic info for https://github.com/itchyny/lightline.vim
    let g:lightline = {
          \ 'colorscheme': 'wombat',
          \ 'active': {
          \   'left': [ [ 'mode', 'paste' ],
          \             [ 'cocstatus', 'readonly', 'filename', 'modified' ] ]
          \ },
          \ 'component_function': {
          \   'cocstatus': 'coc#status'
          \ },
          \ }


    " Using CocList
    " Show all diagnostics
    nnoremap <silent> <space>a  :<C-u>CocList diagnostics<cr>
    " Manage extensions
    nnoremap <silent> <space>e  :<C-u>CocList extensions<cr>
    " Show commands
    nnoremap <silent> <space>c  :<C-u>CocList commands<cr>
    " Find symbol of current document
    nnoremap <silent> <space>o  :<C-u>CocList outline<cr>
    " Search workspace symbols
    nnoremap <silent> <space>s  :<C-u>CocList -I symbols<cr>
    " Do default action for next item.
    nnoremap <silent> <space>j  :<C-u>CocNext<CR>
    " Do default action for previous item.
    nnoremap <silent> <space>k  :<C-u>CocPrev<CR>
    " Resume latest coc list
    nnoremap <silent> <space>p  :<C-u>CocListResume<CR>
'''
